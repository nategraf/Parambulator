<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
       /**
       * A demo showing how to use the preStep callback to add a force to a body.
       * This will act like a force field.
       */
      
        const ZEROVEC = new CANNON.Vec3(0,0,0);
        const XUNITVEC = new CANNON.Vec3(1,0,0);
        const YUNITVEC = new CANNON.Vec3(0,1,0);
        const ZUNITVEC = new CANNON.Vec3(0, 0, 1);
        const PREDICTIONTIME = 3;
        const PREDICTIONSTEP = 0.5;
        const GM = 600;
        const M1 = GM/orb.constants.common.G;
		var spawnArkletsOnce = true; 

        var space = false; 
        var b = false; 
        var up = false; 
        var down = false; 
        var left = false; 
        var right = false; 
        console.log(GM);
        console.log(M1);
		
		//these two lines are testing
		var ArkletsPerLayer = 9;	//must be a perfect square; getting an error right now
		var sAPL = Math.sqrt(ArkletsPerLayer);
		
        var demo = new CANNON.Demo();

        function addCollisionBehavior(body, world) {
            body.addEventListener("collide", function (e) {
                demo.removeVisual(this);
                world.remove(this);
                if(body.collidePredicted) {
                    console.log("Predicted collision");
                }
                else {
                    console.log("Unpredicted collision");
                }
            });
        }

        function addTimeStepPathPrediction(body, world) {
            let orbitElems = [];
            if (body.orbitElems) {
                orbitElems = body.orbitElems;
            }
            else {
                let x = [body.position.x, body.position.y, body.position.z];
                let xDot = [body.velocity.x, body.velocity.y, body.velocity.z];
                orbitElems = orb.position.stateToKepler(x, xDot, 0, M1);
            }
            let projectionShape = new CANNON.Sphere(body.shapes[0].radius); // WARNING: Only works for spherical bodies
            projectionShape.collisionResponse = false;
            for (let i = 1; i <= PREDICTIONTIME / PREDICTIONSTEP; i++) {
                let t = i * PREDICTIONSTEP;
                let projection = new CANNON.Body({
                    mass: 1,
                    collisionFilterGroup: 2 << i,
                    collisionFilterMask: 2 << i
                });
                //let quat = new CANNON.Quaternion();
                //quat.setFromEuler(orbitElems[2], -orbitElems[4], orbitElems[3], 'ZYX'); // TODO: Fix this
                projection.addShape(projectionShape);
                projection.addEventListener("collide", function (e) {
                    body.collidePredicted = true;
                });
                world.addEventListener("postStep", function () {
                    if (world.bodies.indexOf(body) != -1) {
                        orbitElems[5] = world.dt * world.stepnumber + t;
                        let cart = orb.position.keplerian(...orbitElems);
                        projection.position = new CANNON.Vec3(...cart[0]);
                        projection.velocity = new CANNON.Vec3(...cart[1]);
                    }
                    else {
                        // If the body no longer exists, delete the projection
                        //demo.removeVisual(projection);
                        world.removeBody(projection);
                        // TODO This causes a minor error in javascript. Figure out how to fix it
                    }
                });
                world.addBody(projection);
                //demo.addVisual(projection);
            }
        }
		
		function LayerNum(i){	//returns which layer an arklet should spawn in
			//influences z direction
			var num = Math.floor(i / ArkletsPerLayer);
			return num;
		}
		
		function LayerLine(i){	//returns which line in a layer the arklet should spawn in
			//influences y direction
			var line = Math.ceil(((i-(ArkletsPerLayer * Math.floor(i / ArkletsPerLayer))) / sAPL));
			if(LinePos(i) == 0){ line += 1;}
			return line;
		}
		
		function LinePos(i){	//returns where in a line an arklet should spawn
			//influences x direction
			var spot = (((i-(ArkletsPerLayer * Math.floor(i / ArkletsPerLayer))) % sAPL))
			return spot;
		}

      var spawnBolides = true; 
	  
	  function addForces(){
        var onwards = demo.getSpace(); 
        return onwards; 
      }
	  
	  function generateArkletCloud(n){
          var izzyPosition = izzy.position; 
          
          var mass = 1; 
          var randomMult = 1; 
          //var shape = new CANNON.Cylinder(.2, .2, 1, 10); 
		  var shape = new CANNON.Sphere(0.1);
          var a = demo.getA() + Math.random()*randomMult; 
          var e = demo.getE() + Math.random() * randomMult/5.0;
          var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
          var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
          var o = orb.common.deg2rad(demo.geto());
          var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0, 0, M1); 

		  var x = izzy.x;
		  var y= izzy.y;
		  var z = izzy.z;	//still overwritten right away
		  var vx = izzy.vx;		//but allow for different spawn conditions
		  var vy = izzy.vy;
		  var vz = izzy.vz;

          var arklets = new Array(); 

          for(var i = 0; i < n; i++){
              var x = izzy.position.x; 	//thse are already initialized above.  why a second time?
              var y = izzy.position.y; 
              var z = izzy.position.z;
              var even = 1;
			  
			var arklet = new CANNON.Body({
			mass: 1,
			//Notes: the +1 for each plane is so the arklets don't spawn touching izzy.
			position: new CANNON.Vec3(x-.75*sAPL+(LayerLine(i)),y+2+(LayerNum(i)),z-1+(LinePos(i)))
			});

              arklet.addShape(shape);
			  //Change this line, a lot will be replacing this
              arklet.velocity.set(izzy.velocity.x,izzy.velocity.y,izzy.velocity.z); 
              arklet.linearDamping = 0.0; 

              arklet.preStep = function(){
			  
              // Get the vector pointing from the moon to the planet center
              var arklet_to_planet = new CANNON.Vec3();
              this.position.negate(arklet_to_planet);
              // Get distance from planet to moon
              var distance = arklet_to_planet.length();
              // Now apply force on moon
              // Fore is pointing in the moon-planet direction
              arklet_to_planet.normalize();
              arklet_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
				//Add in forces acting on Arklet here
				
              }
			  arklet.postStep = function(){
				//Take out forces acting on Arklet here
				
				  /*var IzzyArkletVector = new CANNON.Vec3(arklet.position.x-izzy.position.x, arklet.position.y-izzy.position.y, arklet.position.z-izzy.position.z);
				  var IzzyArkletDistance = IzzyArkletVector.length();
				  console.log(IzzyArkletDistance);
				  var xDistance = IzzyArkletVector.x;
				  var yDistance = IzzyArkletVector.y;
				  var zDistance = IzzyArkletVector.z;
				  arklet.velocity.x = xDistance/IzzyArkletDistance;
				  arklet.velocity.y = yDistance/IzzyArkletDistance;
				  arklet.velocity.z = zDistance/IzzyArkletDistance;
				  if(IzzyArkletDistance > 10){
					arklet.velocity.x =arklet.velocity.x*(1.5);
					arklet.velocity.y =arklet.velocity.y*(1.5);
					arklet.velocity.z =arklet.velocity.z*(1.5);
				  }
				  if(IzzyArkletDistance < 2){
					arklet.velocity.x =arklet.velocity.x*(0.9);
					arklet.velocity.y =arklet.velocity.y*(0.9);
					arklet.velocity.z =arklet.velocity.z*(0.9);
					console.log("reduced speed to" + arklet.velocity);
				  
				  }*/
			  }
			             
			arklets.push(arklet);   
          }
		console.log(arklets.length);
        return arklets;
      }

      function generateBolide(mass, world){
              var redEarth = demo.getRedEarth(); 
              var size = demo.getSize(); 
              var shape = new CANNON.Sphere(size);            

              let randomMult = 1;

              let a = demo.getA() + Math.random()*randomMult; 
              let e = demo.getE() + Math.random() * randomMult/5.0;
              let i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
              let O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
              let o = orb.common.deg2rad(demo.geto());
              let m0 = Math.PI * 2 * Math.random();
              let orbitElems = [a, e, i, O, o, world.dt * world.stepnumber, 0, m0, M1];
              var cartesian = orb.position.keplerian(...orbitElems);

              var bolide = new CANNON.Body({
                mass: mass, 
                position: new CANNON.Vec3(...cartesian[0])
              });

              bolide.addShape(shape); 
              bolide.velocity.set(...cartesian[1]);
              bolide.linearDamping = 0.0;
              bolide.orbitElems = orbitElems; // Define our own member for storing the needed information

              bolide.preStep = function(){
                // Get the vector pointing from the moon to the planet center
                var bolide_to_planet = new CANNON.Vec3();
                this.position.negate(bolide_to_planet);
                // Get distance from planet to moon
                var distance = bolide_to_planet.length();
                // Now apply force on moon
                // Fore is pointing in the moon-planet direction
                bolide_to_planet.normalize();
                bolide_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
              }


              return bolide; 
      }

	  function generateIzzy(){
          var mass = 1; 
          var shape = new CANNON.Cylinder(1,1, 5, 10);  
          var randomMult  = 1; 
          var a = demo.getA() + Math.random()*randomMult; 
          var e = demo.getE() + Math.random() * randomMult/5.0;
          var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
          var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
          var o = orb.common.deg2rad(demo.geto());
          var cartesian = orb.position.keplerian(a+40, e, i, O, o, 0, 0, 0, M1); 

          var x = cartesian[0][0]; 
          var y = cartesian[0][1]; 
          var z = cartesian[0][2]; 
          var vx = (cartesian[1][0]);
          var vy = (cartesian[1][1]);
          var vz = (cartesian[1][2]);          

          var izzy = new CANNON.Body({
              mass: mass, 
              position: new CANNON.Vec3(x,y,z)
              });

          izzy.velocity.set(vx,vy,vz);
          izzy.linearDamping = 0.0; 

          izzy.addShape(shape); 

      izzy.preStep = function(){
                forward = demo.getSpace(); 
                // Get the vector pointing from the moon to the planet center
                var izzy_to_planet = new CANNON.Vec3();
                var temp = new CANNON.Vec3(); 
                this.position.negate(temp); 
                temp.normalize(); 
                this.position.negate(izzy_to_planet);
              //   // Get distance from planet to moon
                var distance = izzy_to_planet.length();
              //   // Now apply force on moon
              //   // Fore is pointing in the moon-planet direction
                izzy_to_planet.normalize();
                izzy_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
                debugger;

                if(space == true){

                  this.velocity.x = this.velocity.x * 1.10; 
                  this.velocity.y = this.velocity.y * 1.10; 
                  this.velocity.z = this.velocity.z * 1.10;
                  space = false; 
                }

                if(b == true){
                this.velocity.x = this.velocity.x *.75; 
                this.velocity.y = this.velocity.y *.75; 
                this.velocity.z = this.velocity.z *.75; 

                b = false; 
                }

                if(left == true){
                  if(temp.x > 0)
                    temp.x = 1 - temp.x; 
                  else
                    temp.x = 1 + temp.x; 

                  if(temp.y > 0)
                    temp.y = 1 - temp.y;
                  else 
                    temp.y = 1 + temp.y; 
                  if(temp.z > 0)
                    temp.z = 1 - temp.z; 
                  else
                    temp.z = 1 + temp.z; 

                  this.velocity.x -= (temp.x*1);
                  this.velocity.y -= (temp.y*1); 
                  this.velocity.z -= (temp.z*1); 
   
                  left = false; 
                }

                if(right == true){
                  if(temp.x >0)
                    temp.x = 1 - temp.x; 
                  else
                    temp.x = 1 + temp.x; 

                  if(temp.y > 0)
                    temp.y = 1 - temp.y;
                  else 
                    temp.y = 1 + temp.y; 
                  if(temp.z > 0)
                    temp.z = 1 - temp.z; 
                  else
                    temp.z = 1 + temp.z; 

                  this.velocity.x += (temp.x*1);
                  this.velocity.y += (temp.y*1); 
                  this.velocity.z += (temp.z*1); 
   
                  right = false; 
                }

                if(up == true){
                this.velocity.x -= (temp.x *1);  
                this.velocity.y -= (temp.y *1);  
                this.velocity.z -= (temp.z *1);  
                up = false; 
                } 

                if(down == true){
                this.velocity.x += (temp.x *1);  
                this.velocity.y += (temp.y *1);  
                this.velocity.z += (temp.z *1); 
                down = false; 
                }
            
              }
          return izzy; 
      }
	  
	  
      var index = 0; 
	  var izzy;
	  
      demo.addScene("Bolides", function(){
		  index = 0;
		  izzy = generateIzzy(); 
		  
          var world = demo.getWorld();
          var moonShape = new CANNON.Sphere(0.5);

          var planetShape = new CANNON.Sphere(8);   
          var planet = new CANNON.Body({ mass: 0 });
          planet.addShape(planetShape);

                // Use the preStep callback to apply the gravity force on the moon.
                // This callback is evoked each timestep.
            world.addEventListener("preStep", function() {
			var numberOfArklets = demo.getNumberOfArklets(); 
            var spawnArklets = demo.getSpawnArklets(); 
            spawnBolides = demo.getSpawnBolides(); 
            var frequency = demo.getFrequency(); 
			var forward = demo.getSpace();  
            var backward = demo.getB(); 
            var testAngular = demo.getLeft();
            var testAngularOpposite = demo.getRight();  
            var getUp = demo.getUp(); 
            var getDown = demo.getDown();
			
			if(forward == true){
            space = true; 
            // izzy.force.x += izzy.shapes[0].faceNormals[10].x*100; 
            // izzy.force.y += izzy.shapes[0].faceNormals[10].y*100;
            // izzy.force.z += izzy.shapes[0].faceNormals[10].z*100;
            demo.setSpace();                             
            }

            if(backward == true){
            b = true; 
            // izzy.force.x -= izzy.shapes[0].faceNormals[10].x*100; 
            // izzy.force.y -= izzy.shapes[0].faceNormals[10].y*100;
            // izzy.force.z -= izzy.shapes[0].faceNormals[10].z*100;
            demo.setB();  
            }

            if(testAngular == true){
            left = true; 
            //izzy.angularVelocity.x += 1; 
            demo.setLeft(); 
            }

            if(testAngularOpposite == true){
            right = true; 
            //izzy.angularVelocity.x -= 1; 
            demo.setRight(); 
            }

            if(getUp == true){
            up = true; 
            demo.setUp(); 
            }

            if(getDown == true){
            down = true; 
            demo.setDown(); 
            }
			
			if(spawnArklets && spawnArkletsOnce){
              var arklets = generateArkletCloud(numberOfArklets); 
              for(var i = 0; i<arklets.length; i++){
                  world.addBody(arklets[i]);
                  demo.addVisual(arklets[i]); 
              }
              spawnArkletsOnce = false; 

            }
			
            if(spawnBolides){
                if((index % frequency) == 0){
                var bolide = generateBolide(5, world);
                addTimeStepPathPrediction(bolide, world); // Add the path projections!
                addCollisionBehavior(bolide, world)
                
                world.addBody(bolide); 
                demo.addVisual(bolide); 
				debugger;
                }
            }

          index++; 
          });
		  
		  world.addBody(izzy); 
          demo.addVisual(izzy); 
          debugger;
          // We add the objects to the world to simulate them
          //demo.spawnBolide(bolide);
          world.addBody(planet);
          //world.addBody(bolide); 
          // And we add them to the demo to make them visible
          demo.addVisual(planet);
          //demo.addVisual(bolide); 
         // spawnBolide(bolide); 
        });
        
        demo.start();
     </script>
  </body>
</html>