<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
       /**
       * A demo showing how to use the preStep callback to add a force to a body.
       * This will act like a force field.
       */
      
        const ZEROVEC = new CANNON.Vec3(0,0,0);
        const XUNITVEC = new CANNON.Vec3(1,0,0);
        const YUNITVEC = new CANNON.Vec3(0,1,0);
        const ZUNITVEC = new CANNON.Vec3(0,0,1);
        const GM = 300;
        const M1 = GM/orb.constants.common.G;
        var spawnArkletsOnce = true; 

        var space = false; 
        var b = false; 
        var up = false; 
        var down = false; 
        var left = false; 
        var right = false; 
        console.log(GM);
        console.log(M1);

        var demo = new CANNON.Demo();

        CANNON.Trimesh.createEllipse = function (semimajor, eccentricity, tube, radialSegments, tubularSegments, arc) {
            semimajor = semimajor || 1;
            eccentricity = eccentricity || 0;
            tube = tube || 0.5;
            radialSegments = radialSegments || 8;
            tubularSegments = tubularSegments || 6;
            arc = arc || Math.PI * 2;
                    
            var vertices = [];
            var indices = [];
        
            for ( var j = 0; j <= radialSegments; j ++ ) {
                for ( var i = 0; i <= tubularSegments; i ++ ) {
                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * Math.PI * 2;
        
                    let radius = (semimajor * (1 - Math.pow(eccentricity,2)))/(1 + eccentricity * Math.cos(u));
        
                    var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                    var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                    var z = tube * Math.sin( v );
        
                    vertices.push( x, y, z );
                }
            }
        
            for ( var j = 1; j <= radialSegments; j ++ ) {
                for ( var i = 1; i <= tubularSegments; i ++ ) {
                    var a = ( tubularSegments + 1 ) * j + i - 1;
                    var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                    var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                    var d = ( tubularSegments + 1 ) * j + i;
        
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        
            return new CANNON.Trimesh(vertices, indices);
        };


        
        function addEllipticalProjection(body, world){
            let cylLength = 10;
            let x = [body.position.x, body.position.y, body.position.z];
            let xDot = [body.velocity.x, body.velocity.y, body.velocity.z];
            let orbitElems = orb.position.stateToKepler(x, xDot, 0, M1);
            let projectionShape = CANNON.Trimesh.createEllipse(orbitElems[0], orbitElems[1], body.shapes[0].radius, 8, 32);
            projectionShape.collisionResponse = false;
            let projection = new CANNON.Body({
                mass: 1,
                collisionFilterGroup: 2,
                collisionFilterMask: 2
            });
            let quat = new CANNON.Quaternion();
            quat.setFromEuler(orbitElems[2], -orbitElems[4], orbitElems[3], 'ZYX'); // TODO: Fix this
            projection.addShape(projectionShape, ZEROVEC, quat);
/*          projection.addEventListener("collide", function (e) {
            });*/
            world.addEventListener("postStep", function () {
                if (world.bodies.indexOf(body) != -1) {
                }
                else {
                    // If the body no longer exists, delete the projection
                    demo.removeVisual(projection);
                    world.removeBody(projection);
                    // TODO This causes a minor error in javascript. Figure out how to fix it
                }
            });
            world.addBody(projection);
            demo.addVisual(projection);
        }

        function addCollisionBehavior(body, world) {
            body.addEventListener("collide", function (e) { demo.removeVisual(this); world.remove(this); });
        }

      var spawnBolides = true; 

      function addForces(){
        var onwards = demo.getSpace(); 
        return onwards; 
      }

      function generateArkletCloud(n){
          var izzyPosition = izzy.position; 
          
          var mass = 1; 
          var randomMult = 1; 
          var shape = new CANNON.Cylinder(.2, .2, 1, 10); 
          var a = demo.getA() + Math.random()*randomMult; 
          var e = demo.getE() + Math.random() * randomMult/5.0;
          var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
          var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
          var o = orb.common.deg2rad(demo.geto());
          var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0, 0, M1); 

          var x = cartesian[0][0]; 
          var y = cartesian[0][1]; 
          var z = cartesian[0][2]; 
          var vx = (cartesian[1][0]);
          var vy = (cartesian[1][1]);
          var vz = (cartesian[1][2]);

          var arklets = new Array(); 

          for(var i = 0; i < n; i++){
              var x = izzy.position.x; 
              var y = izzy.position.y; 
              var z = izzy.position.z;
              var even = 1; 

              if(i%2 == 0) 
                even = -1; 

              if(i< 11){
                var arklet = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(x+(.5*i*even)+(3*even),y+(.5*i*even)+(3*even),z+(3*even))
                });
              } 
              else {
                var arklet = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(x+(.5*(i-10)*even)+(3*even),y+(.5*(i-10)*even)+(3*even),z+(-3*even))
                });

              }  

              arklet.addShape(shape);
              arklet.velocity.set(izzy.velocity.x,izzy.velocity.y,izzy.velocity.z); 
              arklet.linearDamping = 0.0; 

              arklet.preStep = function(){
              // Get the vector pointing from the moon to the planet center
              var arklet_to_planet = new CANNON.Vec3();
              this.position.negate(arklet_to_planet);
              // Get distance from planet to moon
              var distance = arklet_to_planet.length();
              // Now apply force on moon
              // Fore is pointing in the moon-planet direction
              arklet_to_planet.normalize();
              arklet_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
              }

              arklets.push(arklet);   
          }
        return arklets; 
      }

      function generateBolide(mass){
              var redEarth = demo.getRedEarth(); 
              var size = demo.getSize(); 
              var shape = new CANNON.Sphere(size);            

              let randomMult = 1;

              var a = demo.getA() + Math.random()*randomMult; 
              var e = demo.getE() + Math.random() * randomMult/5.0;
              var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
              var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
              var o = orb.common.deg2rad(demo.geto());
              var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0, 0, M1); 

              var x = cartesian[0][0]; 
              var y = cartesian[0][1]; 
              var z = cartesian[0][2]; 
              var vx = (cartesian[1][0]);
              var vy = (cartesian[1][1]);
              var vz = (cartesian[1][2]);

              // var x = Math.floor((Math.random() * 10) + -5)*10;
              // var y = Math.floor((Math.random() * 10) + -5)*10;
              // var z = Math.floor((Math.random() * 10) + -5)*10;

              // var vx = demo.getVX(); 
              // var vy = demo.getVY(); 
              // var vz = demo.getVZ(); 

             
              // if(redEarth == true){
              //   if(x <0){
              //     vx =vx *(-1); 
              //   }
              //   if(y <0){
              //     vy =vy *(-1); 
              //   }
              //   if(z <0){
              //     vz =vz *(-1); 
              //   }
              // }
              var bolide = new CANNON.Body({
                mass: mass, 
                position: new CANNON.Vec3(x,y,z)
              });

              bolide.addShape(shape); 
              bolide.velocity.set(vx,vy,vz);
              debugger;
              bolide.linearDamping = 0.0; 

              bolide.preStep = function(){
                // Get the vector pointing from the moon to the planet center
                var bolide_to_planet = new CANNON.Vec3();
                this.position.negate(bolide_to_planet);
                // Get distance from planet to moon
                var distance = bolide_to_planet.length();
                // Now apply force on moon
                // Fore is pointing in the moon-planet direction
                bolide_to_planet.normalize();
                bolide_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
              }


              return bolide; 
      }

      function generateIzzy(){
          var mass = 1; 
          var shape = new CANNON.Cylinder(1,1, 5, 10);  
          var randomMult  = 1; 
          var a = demo.getA() + Math.random()*randomMult; 
          var e = demo.getE() + Math.random() * randomMult/5.0;
          var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
          var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
          var o = orb.common.deg2rad(demo.geto());
          var cartesian = orb.position.keplerian(a+40, e, i, O, o, 0, 0, 0, M1); 

          var x = cartesian[0][0]; 
          var y = cartesian[0][1]; 
          var z = cartesian[0][2]; 
          var vx = (cartesian[1][0]);
          var vy = (cartesian[1][1]);
          var vz = (cartesian[1][2]);          

          var izzy = new CANNON.Body({
              mass: mass, 
              position: new CANNON.Vec3(x,y,z)
              });

          izzy.velocity.set(vx,vy,vz);
          izzy.linearDamping = 0.0; 

          izzy.addShape(shape); 

      izzy.preStep = function(){
                forward = demo.getSpace(); 
                // Get the vector pointing from the moon to the planet center
                var izzy_to_planet = new CANNON.Vec3();
                var temp = new CANNON.Vec3(); 
                this.position.negate(temp); 
                temp.normalize(); 
                this.position.negate(izzy_to_planet);
              //   // Get distance from planet to moon
                var distance = izzy_to_planet.length();
              //   // Now apply force on moon
              //   // Fore is pointing in the moon-planet direction
                izzy_to_planet.normalize();
                izzy_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
                debugger;

                if(space == true){

                  this.velocity.x = this.velocity.x * 1.10; 
                  this.velocity.y = this.velocity.y * 1.10; 
                  this.velocity.z = this.velocity.z * 1.10;
                  space = false; 
                }

                if(b == true){
                this.velocity.x = this.velocity.x *.75; 
                this.velocity.y = this.velocity.y *.75; 
                this.velocity.z = this.velocity.z *.75; 

                b = false; 
                }

                if(left == true){
                  if(temp.x > 0)
                    temp.x = 1 - temp.x; 
                  else
                    temp.x = 1 + temp.x; 

                  if(temp.y > 0)
                    temp.y = 1 - temp.y;
                  else 
                    temp.y = 1 + temp.y; 
                  if(temp.z > 0)
                    temp.z = 1 - temp.z; 
                  else
                    temp.z = 1 + temp.z; 

                  this.velocity.x -= (temp.x*1);
                  this.velocity.y -= (temp.y*1); 
                  this.velocity.z -= (temp.z*1); 
   
                  left = false; 
                }

                if(right == true){
                  if(temp.x >0)
                    temp.x = 1 - temp.x; 
                  else
                    temp.x = 1 + temp.x; 

                  if(temp.y > 0)
                    temp.y = 1 - temp.y;
                  else 
                    temp.y = 1 + temp.y; 
                  if(temp.z > 0)
                    temp.z = 1 - temp.z; 
                  else
                    temp.z = 1 + temp.z; 

                  this.velocity.x += (temp.x*1);
                  this.velocity.y += (temp.y*1); 
                  this.velocity.z += (temp.z*1); 
   
                  right = false; 
                }

                if(up == true){
                this.velocity.x -= (temp.x *1);  
                this.velocity.y -= (temp.y *1);  
                this.velocity.z -= (temp.z *1);  
                up = false; 
                } 

                if(down == true){
                this.velocity.x += (temp.x *1);  
                this.velocity.y += (temp.y *1);  
                this.velocity.z += (temp.z *1); 
                down = false; 
                }
            
              }
          return izzy; 


      }

      function addLinearPathProjection(body, world) {
          let cylLength = 10;
          let projectionShape = new CANNON.Cylinder(body.shapes[0].radius, body.shapes[0].radius, cylLength, 20);
          projectionShape.collisionResponse = false;
          let projection = new CANNON.Body({
              mass: 1,
              collisionFilterGroup: 2,
              collisionFilterMask: 2,
              position: body.position
          });
          projection.addShape(projectionShape, new CANNON.Vec3(0, 0, cylLength / 2.0));
          projection.addEventListener("collide", function (e) {
              let dangerPeriod = body.shapes[0].radius / e.contact.bi.velocity.length(); // Not quite right, but close
              if (Math.abs((e.contact.ri.length() / e.contact.bi.velocity.length()) - (e.contact.rj.length() / e.contact.bj.velocity.length())) < dangerPeriod) {
                  console.log("Orbiting body collision predicted");
                  // TODO: Change color of the orbiting body needs to be added here
              }
          });
          world.addEventListener("postStep", function () {
              if (world.bodies.indexOf(body) != -1) {
                  projection.quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), body.velocity);
                  projection.velocity.copy(body.velocity);
              }
              else {
                  demo.removeVisual(projection);
                  world.removeBody(projection);
                  // TODO This causes a minor error in javascript. Figure out how to fix it
              }
          });
          world.addBody(projection);
      }

      function addCollisionBehavior(body, world) {
          body.addEventListener("collide", function (e) { demo.removeVisual(this); world.remove(this); });
      }

      var i = 0; 
      var izzy;

demo.addScene("Bolides", function(){
          izzy = generateIzzy(); 

          var world = demo.getWorld();
          var moonShape = new CANNON.Sphere(0.5);
          //var cylinder = new CANNON.Cylinder(1); 
          var planetShape = new CANNON.Sphere(8);   
          var planet = new CANNON.Body({ mass: 0 });
         

              //bolide.velocity.set(vx,vy,vz);
              //bolide.linearDamping = 0.0;           
          planet.addShape(planetShape);
          

                // Use the preStep callback to apply the gravity force on the moon.
                // This callback is evoked each timestep.

          world.addEventListener("preStep", function() {
          var numberOfArklets = demo.getNumberOfArklets(); 
          var spawnArklets = demo.getSpawnArklets(); 
          var spawnBolides = demo.getSpawnBolides(); 
          var frequency = demo.getFrequency();
          var forward = demo.getSpace();  
          var backward = demo.getB(); 
          var testAngular = demo.getLeft();
          var testAngularOpposite = demo.getRight();  
          var getUp = demo.getUp(); 
          var getDown = demo.getDown(); 

          //Izzy Controls - will encapsulate this if I have extra time. 
          if(forward == true){
            space = true; 
            // izzy.force.x += izzy.shapes[0].faceNormals[10].x*100; 
            // izzy.force.y += izzy.shapes[0].faceNormals[10].y*100;
            // izzy.force.z += izzy.shapes[0].faceNormals[10].z*100;
            demo.setSpace();                             
          }

          if(backward == true){
            b = true; 
            // izzy.force.x -= izzy.shapes[0].faceNormals[10].x*100; 
            // izzy.force.y -= izzy.shapes[0].faceNormals[10].y*100;
            // izzy.force.z -= izzy.shapes[0].faceNormals[10].z*100;
            demo.setB();  
          }

          if(testAngular == true){
            left = true; 
            //izzy.angularVelocity.x += 1; 
            demo.setLeft(); 
          }

          if(testAngularOpposite == true){
            right = true; 
          //izzy.angularVelocity.x -= 1; 
          demo.setRight(); 
          }

          if(getUp == true){
            up = true; 
            demo.setUp(); 
          }

          if(getDown == true){
            down = true; 
            demo.setDown(); 
          }


          if(spawnArklets && spawnArkletsOnce){
              var arklets = generateArkletCloud(numberOfArklets); 
              for(var i = 0; i<arklets.length; i++){
                  world.addBody(arklets[i]);
                  demo.addVisual(arklets[i]); 
              }
              spawnArkletsOnce = false; 

          }

          if(spawnBolides){
              if((i % frequency) == 0){
                var bolide = generateBolide(5, moonShape);

                //addEllipticalProjection(bolide, world); // Add the path projections!
                //addCollisionBehavior(bolide, world)
                
                world.addBody(bolide); 
                demo.addVisual(bolide); 
              }
          }
          i++;
          });

          world.addBody(izzy); 
          demo.addVisual(izzy); 
          debugger;
          // We add the objects to the world to simulate them
          //demo.spawnBolide(bolide);
          world.addBody(planet);
          //world.addBody(bolide); 
          // And we add them to the demo to make them visible
          demo.addVisual(planet);
          //demo.addVisual(bolide); 
         // spawnBolide(bolide); 
        });
        
        demo.start();
     </script>
  </body>
</html>