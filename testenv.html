<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
      /**
       * A demo showing how to use the preStep callback to add a force to a body.
       * This will act like a force field.
       */

      var spawnBolides = true; 

      function generateBolide(mass){
              var redEarth = demo.getRedEarth(); 
              var size = demo.getSize(); 
              var speed = demo.getSpeed(); 
              var shape = new CANNON.Sphere(size); 
              debugger;
            

              var a = demo.getA(); 
              var e = demo.getE(); 
              var i = demo.getI(); 
              var O = demo.getO(); 
              var o = demo.geto(); 
              var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0); 


              // var x = Math.floor((Math.random() * 10) + -5)*10;
              // var y = Math.floor((Math.random() * 10) + -5)*10;
              // var z = Math.floor((Math.random() * 10) + -5)*10;
              var x = cartesian[0][0]; 
              var y = cartesian[0][1]; 
              var z = cartesian[0][2]; 
              // var vx = demo.getVX(); 
              // var vy = demo.getVY(); 
              // var vz = demo.getVZ(); 

              var vx = (cartesian[1][0]/10000000);
              var vy = (cartesian[1][1]/10000000);
              var vz = (cartesian[1][2]/10000000);
              // if(redEarth == true){
              //   if(x <0){
              //     vx =vx *(-1); 
              //   }
              //   if(y <0){
              //     vy =vy *(-1); 
              //   }
              //   if(z <0){
              //     vz =vz *(-1); 
              //   }
              // }
              var bolide = new CANNON.Body({
                mass: mass, 
                position: new CANNON.Vec3(x,y,z)
              });

              bolide.addShape(shape); 
              bolide.velocity.set(-vx*speed,-vy*speed,-vz*speed);
              bolide.linearDamping =0.0; 

              bolide.preStep = function(){
                // Get the vector pointing from the moon to the planet center
                var bolide_to_planet = new CANNON.Vec3();
                this.position.negate(bolide_to_planet);
                // Get distance from planet to moon
                var distance = bolide_to_planet.norm();
                // Now apply force on moon
                // Fore is pointing in the moon-planet direction
                bolide_to_planet.normalize();
                bolide_to_planet.mult((300*mass)/Math.pow(distance,2),this.force);
              }


              return bolide; 
      }

      function addLinearPathProjection(body, world) {
          let cylLength = 10;
          let projectionShape = new CANNON.Cylinder(body.shapes[0].radius, body.shapes[0].radius, cylLength, 20);
          projectionShape.collisionResponse = false;
          let projection = new CANNON.Body({
              mass: 1,
              collisionFilterGroup: 2,
              collisionFilterMask: 2,
              position: body.position
          });
          projection.addShape(projectionShape, new CANNON.Vec3(0, 0, cylLength / 2.0));
          projection.addEventListener("collide", function (e) {
              let dangerPeriod = body.shapes[0].radius / e.contact.bi.velocity.length(); // Not quite right, but close
              if (Math.abs((e.contact.ri.length() / e.contact.bi.velocity.length()) - (e.contact.rj.length() / e.contact.bj.velocity.length())) < dangerPeriod) {
                  console.log("Orbiting body collision predicted");
                  // TODO: Change color of the orbiting body needs to be added here
              }
          });
          world.addEventListener("postStep", function () {
              if (world.bodies.indexOf(body) != -1) {
                  projection.quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), body.velocity);
                  projection.velocity.copy(body.velocity);
              }
              else {
                  demo.removeVisual(projection);
                  world.removeBody(projection);
                  // TODO This causes a minor error in javascript. Figure out how to fix it
              }
          });
          world.addBody(projection);
      }

      function addCollisionBehavior(body, world) {
          body.addEventListener("collide", function (e) { demo.removeVisual(this); world.remove(this); });
      }

      var i = 0; 
      var demo = new CANNON.Demo();
      demo.addScene("Moon",function(){
          var world = demo.getWorld();
          var mass = 5;
          var moonShape = new CANNON.Sphere(0.5);
          var planetShape = new CANNON.Sphere(3.5);
          var moon = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(5,0,0)
          });
          
          moon.addShape(moonShape);

          var planet = new CANNON.Body({ mass: 0 });
          planet.addShape(planetShape);
          moon.velocity.set(0,0,8);
          moon.linearDamping = 0.0;
          

          // Use the preStep callback to apply the gravity force on the moon.
          // This callback is evoked each timestep.
	  world.addEventListener("preStep", function() {
      spawnBolides = demo.getSpawnBolides(); 
      debugger;
      var bolide = generateBolide(5, moonShape);
      addLinearPathProjection(bolide, world); // Add the path projections!
      var frequency = demo.getFrequency(); 
         debugger;
      if(spawnBolides){
        if((i % frequency) ==0){
          world.addBody(bolide); 
          demo.addVisual(bolide); 
        }
      }

    

          i++; 

	  });

          moon.preStep = function(){
            // Get the vector pointing from the moon to the planet center
            var moon_to_planet = new CANNON.Vec3();
            this.position.negate(moon_to_planet);
            // Get distance from planet to moon
            var distance = moon_to_planet.norm();
            // Now apply force on moon
            // Fore is pointing in the moon-planet direction
            moon_to_planet.normalize();
            moon_to_planet.mult(1500/Math.pow(distance,2),this.force);
          }
          // We add the objects to the world to simulate them
          //demo.spawnBolide(bolide);
          world.addBody(moon); 
          world.addBody(planet);
          //world.addBody(bolide); 
          // And we add them to the demo to make them visible
          demo.addVisual(planet);
          demo.addVisual(moon); 
          //demo.addVisual(bolide); 
         // spawnBolide(bolide); 
        });
      demo.start();
    </script>
  </body>
</html>
