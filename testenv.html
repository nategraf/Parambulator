<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
       /**
       * A demo showing how to use the preStep callback to add a force to a body.
       * This will act like a force field.
       */
	   
	   
	   /*
	   danger = red, take corrective measures
	   too far away = yellow
	   need to correct velocity vector = some other indicator
	   */
      
		const VISUALIZEPROJECTIONS = false;
        const ZEROVEC = new CANNON.Vec3(0,0,0);
        const XUNITVEC = new CANNON.Vec3(1,0,0);
        const YUNITVEC = new CANNON.Vec3(0,1,0);
        const ZUNITVEC = new CANNON.Vec3(0, 0, 1);
        const PREDICTIONTIME = 3;
        const MINPREDICTIONSTEP = 0.25;
        const GM = 1200;
        const M1 = GM/orb.constants.common.G;
		const AVOIDANCETHRUST = 40;
		const FOLLOWTHRUST = 10;
		const CORRECTIONTHRUST = 10;
		const IZZYTHRUST = 50;
		const CORRECTIONTHRESHOLD = 3;
		const INNERENVELOPE = 7;
		const OUTERENVELOPE = 17;
		const PERSONALSPACEFACTOR = 5;
		var spawnArkletsOnce = true; 

        var space = false; 
        var b = false; 
        var up = false; 
        var down = false; 
        var left = false; 
        var right = false; 
		
		//these two lines are testing
		var ArkletsPerLayer = 9;	//must be a perfect square
		var sqrtAPL = Math.sqrt(ArkletsPerLayer);
		
        var demo = new CANNON.Demo();

        function addArkletCollisionBehavior(body, world) {
            body.addEventListener("collide", function (e) {
                demo.removeVisual(this);
                world.remove(this);
                console.log("ARKLET COLLISION!!!");
            });
        }

        function addBolideCollisionBehavior(body, world) {
            body.addEventListener("collide", function (e) {
                if (e.contact.bi.isPlanet || e.contact.bj.isPlanet) {
                    demo.removeVisual(this);
                    world.remove(this);
                }
                else {
                    body.needsOrbitalUpdate = true;
                }
                console.log("bolide collision");
            });
        }

        function addTimeStepPathPrediction(body, world, intelligent) {
            let orbitElems = [];
            if (body.orbitElems) {
                orbitElems = body.orbitElems;
            }
            else {
                let x = body.position.toArray();
                let xDot = body.velocity.toArray();
                orbitElems = orb.position.stateToKepler(x, xDot, 0, M1);
            }
            let projectionShape = new CANNON.Sphere(body.shapes[0].radius); // WARNING: Only works for spherical bodies
            projectionShape.collisionResponse = false;
            for (let i = 1; i <= PREDICTIONTIME / MINPREDICTIONSTEP ; i++) {
                let t = i * MINPREDICTIONSTEP;
                let projection = new CANNON.Body({
                    mass: 1,
                    collisionFilterGroup: 2 << i,
                    collisionFilterMask: 2 << i
                });
                projection.addShape(projectionShape);

                world.addEventListener("postStep", function () {
					if (world.bodies.indexOf(body) != -1) {
                        orbitElems = body.orbitElems; // T0 (perihelion passage/epoch) may be NaN, which means the object has left orbit
                        if(Number.isNaN(orbitElems[6])){
                            // Hyperbolic orbit prediction, approximated by linear projection (Which is mostly good enough)
                            projection.velocity.copy(body.velocity);
                            body.position.vadd(body.velocity.scale(t), projection.position);
                        }
                        else{
                            // Normal stable orbit prediction, using keplars equations provided by orb.js
                            orbitElems[5] = world.dt * world.stepnumber + t;
                            let cart = orb.position.keplerian(...orbitElems);
                            projection.position = new CANNON.Vec3(...cart[0]);
                            projection.velocity = new CANNON.Vec3(...cart[1]);
                        }             
                    }
                    else {
                        // If the body no longer exists, delete the projection
                        if(VISUALIZEPROJECTIONS) demo.removeVisual(projection);
                        world.removeBody(projection);
                        // TODO This causes a minor error in javascript. Figure out how to fix it
                    }
                });
                if (intelligent) addCollisionAvoidance(body, projection, world);
                if (intelligent) addPersonalSpace(body, world);
                world.addBody(projection);
                if(VISUALIZEPROJECTIONS) demo.addVisual(projection);
            }
        }
		
		function addCollisionAvoidance(avoider, projection, world) {
		    projection.addEventListener("collide", function (e) {
		        if (!avoider.maneuvering) { // Dont add additioal force if the avoider is already thrusting, but the game is lagging
		            let direction = new CANNON.Vec3();
		            if (projection === e.contact.bi) { // Check to see if this projection is bi or bj in the collision
		                e.contact.ri.negate().unit(direction);
		            }
		            else {
		                e.contact.rj.negate().unit(direction);
		            }
		            let thrust = direction.scale(AVOIDANCETHRUST);
		            avoider.force.vadd(thrust, avoider.force);

		            avoider.needsOrbitalUpdate = true;
		            avoider.maneuvering = true;
		        }
            });
		}

		function addPersonalSpace(body, world) {
		    let bubbleShape = new CANNON.Sphere(body.shapes[0].radius * PERSONALSPACEFACTOR); // WARNING: Only works for spherical bodies
		    bubbleShape.collisionResponse = false;
		    let bubble = new CANNON.Body({
		        mass: 1,
		        collisionFilterGroup: 1 << 15,
		        collisonFilterMask: 1 << 15
		    });
		    bubble.addShape(bubbleShape);
		    world.addEventListener("postStep", function () {
		        if (world.bodies.indexOf(body) != -1) {
		            bubble.velocity.copy(body.velocity);
		            bubble.position.copy(body.position);
		        }
		        else {
		            // If the body no longer exists, delete the projection
		            if (VISUALIZEPROJECTIONS) demo.removeVisual(bubble);
		            world.removeBody(bubble);
		            // TODO This causes a minor error in javascript. Figure out how to fix it
		        }
		    });

		    bubble.addEventListener("collide", function (e) {
		        if (!this.maneuvering) {
		            let direction = new CANNON.Vec3();
		            if (bubble === e.contact.bi) { // Check to see if this projection is bi or bj in the collision
		                e.contact.ri.negate().unit(direction);
		            }
		            else {
		                e.contact.rj.negate().unit(direction);
		            }
		            let thrust = direction.scale(AVOIDANCETHRUST);
		            body.force.vadd(thrust, body.force);

		            body.needsOrbitalUpdate = true;
		        }
		    });

		    world.addBody(bubble);
		    if (VISUALIZEPROJECTIONS) demo.addVisual(bubble);
		}
		
		function addBodyFollowing(follower, destination, world) {
            world.addEventListener("preStep", function (e) {
				let FtoD = new CANNON.Vec3();
				follower.position.vsub(destination.position, FtoD);
				let temp = 0;
				if(FtoD.length() < 2){temp = -1;} //when too close to izzy
				if(FtoD.length() > 2){temp = 1;} //when too far from izzy
				FtoD.normalize();
                let thrust = FtoD.scale(AVOIDANCETHRUST * temp);
                follower.force.vadd(thrust, follower.force);
                follower.needsOrbitalUpdate = true;
            });
        }
		
		function LayerNum(i){	//returns which layer an arklet should spawn in
			//influences z direction
			let num = Math.floor(i / ArkletsPerLayer);
			return num;
		}
		
		function LayerLine(i){	//returns which line in a layer the arklet should spawn in
			//influences y direction
		    let line = Math.ceil(((i - (ArkletsPerLayer * Math.floor(i / ArkletsPerLayer))) / sqrtAPL));
			if(LinePos(i) == 0){ line += 1;}
			return line;
		}
		
		function LinePos(i){	//returns where in a line an arklet should spawn
			//influences x direction
		    let spot = (((i - (ArkletsPerLayer * Math.floor(i / ArkletsPerLayer))) % sqrtAPL))
			return spot;
		}

      var spawnBolides = true; 
	  
	  function addForces(){
        let onwards = demo.getSpace(); 
        return onwards; 
      }
	  
	  function generateArkletCloud(n, world){         
          let mass = 1; 
          let arkletShape = new CANNON.Sphere(0.2);

		  let x = izzy.x;
		  let y= izzy.y;
		  let z = izzy.z;	//still overwritten right away
		  let vx = izzy.vx;		//but allow for different spawn conditions
		  let vy = izzy.vy;
		  let vz = izzy.vz;

          let arklets = new Array(); 

          for(let i = 0; i < n; i++){
                let x = izzy.position.x; 
                let y = izzy.position.y; 
                let z = izzy.position.z;
			  
			    let arklet = new CANNON.Body({
				        mass: 1,
				        //Notes: need to make if statement which decides which direction is 'behind'
				        position: new CANNON.Vec3(x + INNERENVELOPE - sqrtAPL + (LayerLine(i)), y + INNERENVELOPE + (LayerNum(i)), z + INNERENVELOPE + (LinePos(i)))
			      });
			    arklet.orbitElems = [];
			    arklet.needsOrbitalUpdate = true;
			

			    arklet.addShape(arkletShape);
                arklet.velocity.copy(izzy.velocity); 
                arklet.linearDamping = 0.0; 

                arklet.preStep = function () {
				// Get the vector pointing from the moon to the planet center
				let arklet_to_planet = new CANNON.Vec3();
				this.position.negate(arklet_to_planet);
				// Get distance from planet to moon
				let distance = arklet_to_planet.length();
				// Now apply force on moon
				// Fore is pointing in the moon-planet direction
				arklet_to_planet.normalize();
				arklet_to_planet.scale((GM*mass) / Math.pow(distance, 2), arklet_to_planet);
				this.force.vadd(arklet_to_planet, this.force);
				//Add in forces acting on Arklet here
				
                // Izzy Following
				let FtoD = new CANNON.Vec3();
				this.position.vsub(izzy.position, FtoD);
				let modFollowForce = 0;
				
				/*
				Need to find a force vector going in the direction which pushes the arklet in the direction
				of izzy, and add this to the arklet using vadd
				*/
				if(!this.velocity.almostEquals(izzy.velocity, CORRECTIONTHRESHOLD)){
					let correctionalVector = new CANNON.Vec3();
					izzy.velocity.vsub(this.velocity, correctionalVector);
					correctionalVector.normalize();
					let correctionalThrust = correctionalVector.scale(CORRECTIONTHRUST);
					this.force.vadd(correctionalThrust, this.force);
					this.needsOrbitalUpdate = true;
				}
				if(FtoD.length() < 5){
					modFollowForce = -0.1*(FtoD.length()-INNERENVELOPE);
					this.needsOrbitalUpdate = true;
				} //when too close to izzy
				if(FtoD.length() > 15){
					modFollowForce = -0.1*(FtoD.length()-OUTERENVELOPE);
					this.needsOrbitalUpdate = true;
				} //when too far from izzy
				FtoD.normalize();
				let thrust = FtoD.scale(FOLLOWTHRUST * modFollowForce);
				this.force.vadd(thrust, this.force);
				
				
              }
			  arklet.postStep = function(){
			      this.force.setZero();
			      if (this.maneuvering) {
			          this.maneuvering = false;
			      }

                  if(this.needsOrbitalUpdate){
                      let x = this.position.toArray();
                      let xDot = this.velocity.toArray();
                      this.orbitElems = orb.position.stateToKepler(x, xDot, world.dt * world.stepnumber, M1); // Calculate the new orbital elements after a change in state
                      let t0 = this.orbitElems[5];
                      this.orbitElems.push(t0, 0, M1); // Append the reference elements of epoch, mean anomoly at epoch, and central mass
                      this.needsOrbitalUpdate = false; // Set that this body no longer needs an update                   
                  }
              }
			             
			arklets.push(arklet);   
          }
        return arklets;
      }

      function generateBolide(mass, world){
              let redEarth = demo.getRedEarth(); 
              let size = demo.getSize(); 
              let shape = new CANNON.Sphere(size);            
              let randomMult = 1;
              let a = demo.getA() + Math.random()*randomMult; 
              let e = demo.getE() + Math.random() * randomMult/5.0;
              let i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
              let O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
              let o = orb.common.deg2rad(demo.geto());
              let m0 = Math.PI * 2 * Math.random();
              let orbitElems = [a, e, i, O, o, world.dt * world.stepnumber, 0, m0, M1];
              let cartesian = orb.position.keplerian(...orbitElems);
              let bolide = new CANNON.Body({
                  mass: mass, 
                  position: new CANNON.Vec3(...cartesian[0]),
                  collisionFilterGroup: 1 | 1 << 15,
                  collisionFilterMask: 1 | 1 << 15,
              });
              bolide.addShape(shape); 
              bolide.velocity.set(...cartesian[1]);
              bolide.linearDamping = 0.0;
              bolide.orbitElems = orbitElems; // Define our own member for storing the needed information
              bolide.preStep = function(){
                // Get the vector pointing from the moon to the planet center
                let bolide_to_planet = new CANNON.Vec3();
                this.position.negate(bolide_to_planet);
                // Get distance from planet to moon
                let distance = bolide_to_planet.length();
                // Now apply force on moon
                // Fore is pointing in the moon-planet direction
                bolide_to_planet.normalize();
				bolide_to_planet.scale((GM*mass)/Math.pow(distance,2), bolide_to_planet);
                this.force.vadd(bolide_to_planet, this.force);
              };
			  
			  bolide.postStep = function() {
                  this.force.setZero();
                  
                  if(this.needsOrbitalUpdate){
                      let x = this.position.toArray();
                      let xDot = this.velocity.toArray();
                      this.orbitElems = orb.position.stateToKepler(x, xDot, world.dt * world.stepnumber, M1); // Calculate the new orbital elements after a change in state
                      let t0 = this.orbitElems[5];
                      this.orbitElems.push(t0, 0, M1); // Append the reference elements of epoch, mean anomoly at epoch, and central mass
                      this.needsOrbitalUpdate = false; // Set that this body no longer needs an update                   
                  }
              }

              return bolide; 
      }

	  function generateIzzy(){
          let mass = 20; 
          let shape = new CANNON.Cylinder(1, 1, 5, 10);  
          let randomMult  = 1; 
          let a = demo.getA() + Math.random()*randomMult; 
          let e = demo.getE() + Math.random() * randomMult/5.0;
          let i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
          let O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
          let o = orb.common.deg2rad(demo.geto());
          let cartesian = orb.position.keplerian(a+40, e, i, O, o, 0, 0, 0, M1);        

          let izzy = new CANNON.Body({
              mass: mass, 
              position: new CANNON.Vec3(...cartesian[0])
              });

          izzy.velocity.set(...cartesian[1]);
          izzy.linearDamping = 0.0; 

          izzy.addShape(shape); 

          izzy.preStep = function(){
                forward = demo.getSpace(); 
                // Get the vector pointing from the moon to the planet center
                let izzy_to_planet = new CANNON.Vec3();
                let temp = new CANNON.Vec3(); 
                this.position.negate(temp); 
                temp.normalize(); 
                this.position.negate(izzy_to_planet);
                // Get distance from planet to izzy
                let distance = izzy_to_planet.length();
                // Now apply force on izzy
                // Fore is pointing in the moon-planet direction
                izzy_to_planet.normalize();
                izzy_to_planet.scale((GM * mass) / Math.pow(distance, 2), izzy_to_planet);
                this.force.vadd(izzy_to_planet, this.force);

                if(space == true){
                    let thrust = izzy.velocity.unit();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    space = false;
                }

                if(b == true){
                    let thrust = this.velocity.unit().negate();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    b = false;
                }

                if(left == true){
                    let thrust = this.velocity.cross(this.position).unit().negate();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    left = false;
                }

                if(right == true){
                    let thrust = this.velocity.cross(this.position).unit();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    right = false;
                }

                if(up == true){
                    let thrust = this.position.unit();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    up = false;
                } 

                if(down == true){
                    let thrust = this.position.unit().negate();
                    thrust.scale(IZZYTHRUST, thrust);
                    this.force.vadd(thrust, this.force);

                    down = false;
                }
            
          }

          izzy.postStep = function () {
              izzy.quaternion.setFromVectors(ZUNITVEC, izzy.velocity);
              this.force.setZero();
          }
          return izzy; 
      }
	  
	  
      var index = 0; 
	  var izzy;
	  
      demo.addScene("Bolides", function(){
		  index = 0;
		  izzy = generateIzzy(); 
		  
          let world = demo.getWorld();
          let moonShape = new CANNON.Sphere(0.5);

          let planetShape = new CANNON.Sphere(8);   
          let planet = new CANNON.Body({
			mass: 0,
			collisionFilterGroup:  (2 << (PREDICTIONTIME / MINPREDICTIONSTEP + 1)) - 1, // Collide with all of the projections and bolides
              collisionFilterMask:  (2 << (PREDICTIONTIME / MINPREDICTIONSTEP + 1)) - 1 // Collide with all of the projections and bolides
  		  });
          planet.addShape(planetShape);
          planet.isPlanet = true;

                // Use the preStep callback to apply the gravity force on the moon.
                // This callback is evoked each timestep.
            world.addEventListener("preStep", function() {
			let numberOfArklets = demo.getNumberOfArklets(); 
            let spawnArklets = demo.getSpawnArklets(); 
            spawnBolides = demo.getSpawnBolides(); 
            let frequency = demo.getFrequency(); 
			let forward = demo.getSpace();  
            let backward = demo.getB(); 
            let testAngular = demo.getLeft();
            let testAngularOpposite = demo.getRight();  
            let getUp = demo.getUp(); 
            let getDown = demo.getDown();
			
			if(forward == true){
            space = true; 
            demo.setSpace();                             
            }

            if(backward == true){
            b = true; 
            demo.setB();  
            }

            if(testAngular == true){
            left = true; 
            //izzy.angularVelocity.x += 1; 
            demo.setLeft(); 
            }

            if(testAngularOpposite == true){
            right = true; 
            //izzy.angularVelocity.x -= 1; 
            demo.setRight(); 
            }

            if(getUp == true){
            up = true; 
            demo.setUp(); 
            }

            if(getDown == true){
            down = true; 
            demo.setDown(); 
            }
			
			if(spawnArklets && spawnArkletsOnce){
              let arklets = generateArkletCloud(numberOfArklets, world); 
              for(let i = 0; i<arklets.length; i++){
				  addTimeStepPathPrediction(arklets[i], world, true); // Add the path projections!
                  addArkletCollisionBehavior(arklets[i], world);

                  world.addBody(arklets[i]);
                  demo.addVisual(arklets[i]); 
              }
              spawnArkletsOnce = false; 

            }
			
            if(spawnBolides){
                if((index % frequency) == 0){
                    let bolide = generateBolide(5, world);
                    addTimeStepPathPrediction(bolide, world, false); // Add the path projections!
                    addBolideCollisionBehavior(bolide, world);
                
                    world.addBody(bolide); 
                    demo.addVisual(bolide); 
                }
            }

          index++; 
          });
		  
		  world.addBody(izzy); 
          demo.addVisual(izzy); 
          //demo.spawnBolide(bolide);
          world.addBody(planet);
          // And we add them to the demo to make them visible
          demo.addVisual(planet);

        });
        
        demo.start();
     </script>
  </body>
</html>