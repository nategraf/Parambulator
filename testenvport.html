<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
     	/**
     	* A demo showing how to use the preStep callback to add a force to a body.
     	* This will act like a force field.
     	*/

      const ZEROVEC = new CANNON.Vec3(0,0,0);
      const XUNITVEC = new CANNON.Vec3(1,0,0);
      const YUNITVEC = new CANNON.Vec3(0,1,0);
      const ZUNITVEC = new CANNON.Vec3(0,0,1);
      const GM = 300;
      const M1 = GM/orb.constants.common.G;
      console.log(GM);
      console.log(M1);

      var demo = new CANNON.Demo();

			/**************************/
			/* createEllipse() - BEGIN*/
			/**************************/
      CANNON.Trimesh.createEllipse = function (semimajor, eccentricity, tube,
				radialSegments, tubularSegments, arc) {

        semimajor = semimajor || 1;
        eccentricity = eccentricity || 0;
        tube = tube || 0.5;
        radialSegments = radialSegments || 8;
        tubularSegments = tubularSegments || 6;
        arc = arc || Math.PI * 2;

        var vertices = [];
        var indices = [];

        for ( var j = 0; j <= radialSegments; j ++ ) {
          for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            let radius = (semimajor * (1 - Math.pow(eccentricity,2)))/(1 +
							eccentricity * Math.cos(u));

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
					}
        }

        for ( var j = 1; j <= radialSegments; j ++ ) {
          for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }

        return new CANNON.Trimesh(vertices, indices);
      };
			/************************/
			/* createEllipse() - END*/
			/************************/



			/*************************************/
			/* addEllipticalProjection() - BEGIN */
			/*************************************/
      function addEllipticalProjection(body, world){
        let cylLength = 10;
        let x = [body.position.x, body.position.y, body.position.z];
        let xDot = [body.velocity.x, body.velocity.y, body.velocity.z];
        let orbitElems = orb.position.stateToKepler(x, xDot, 0, M1);
        let projectionShape = CANNON.Trimesh.createEllipse(orbitElems[0],
					orbitElems[1], body.shapes[0].radius, 8, 32);
        projectionShape.collisionResponse = false;
        let projection = new CANNON.Body({
          mass: 1,
          collisionFilterGroup: 2,
          collisionFilterMask: 2
        });
        let quat = new CANNON.Quaternion();
				// TODO fix this
        quat.setFromEuler(orbitElems[2], -orbitElems[4], orbitElems[3], 'ZYX');
        projection.addShape(projectionShape, ZEROVEC, quat);
        world.addEventListener("postStep", function () {
          if (world.bodies.indexOf(body) != -1) {}
          else {
            // If the body no longer exists, delete the projection
            demo.removeVisual(projection);
            world.removeBody(projection);
            // TODO This causes a minor error in javascript. Figure out how to fix it
          }
        });
        world.addBody(projection);
        demo.addVisual(projection);
      }
			/***********************************/
			/* addEllipticalProjection() - END */
			/***********************************/



			/**********************************/
			/* addCollisionBehavior() - BEGIN */
			/**********************************/
      function addCollisionBehavior(body, world) {
        body.addEventListener("collide", function (e) {
					demo.removeVisual(this); world.remove(this); });
        }
			/********************************/
			/* addCollisionBehavior() - END */
			/********************************/




      var spawnBolides = true;
			/****************************/
			/* generateBolide() - BEGIN */
			/****************************/
      function generateBolide(mass){
        var redEarth = demo.getRedEarth();
        var size = demo.getSize();
        var shape = new CANNON.Sphere(size);

        let randomMult = 1;

        var a = demo.getA() + Math.random()*randomMult;
        var e = demo.getE() + Math.random() * randomMult/5.0;
        var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
        var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
        var o = orb.common.deg2rad(demo.geto());
        var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0, 0, M1);

        var x = cartesian[0][0];
        var y = cartesian[0][1];
        var z = cartesian[0][2];

        var vx = (cartesian[1][0]);
        var vy = (cartesian[1][1]);
        var vz = (cartesian[1][2]);
        var bolide = new CANNON.Body({
          mass: mass,
          position: new CANNON.Vec3(x,y,z)
        });

        bolide.addShape(shape);
        bolide.velocity.set(vx,vy,vz);
        bolide.linearDamping = 0.0;

        bolide.preStep = function(){
          // Get the vector pointing from the moon to the planet center
          var bolide_to_planet = new CANNON.Vec3();
          this.position.negate(bolide_to_planet);
          // Get distance from planet to moon
          var distance = bolide_to_planet.length();
          // Now apply force on moon
          // Fore is pointing in the moon-planet direction
          bolide_to_planet.normalize();
          bolide_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
        }


        return bolide;
      }
			/**************************/
			/* generateBolide() - END */
			/**************************/




			/*************************************/
			/* addLinearPathProjection() - BEGIN */
			/*************************************/
      function addLinearPathProjection(body, world) {
        let cylLength = 10;
        let projectionShape = new CANNON.Cylinder(body.shapes[0].radius,
					 body.shapes[0].radius, cylLength, 20);
        projectionShape.collisionResponse = false;
        let projection = new CANNON.Body({
          mass: 1,
          collisionFilterGroup: 2,
          collisionFilterMask: 2,
          position: body.position
        });
        projection.addShape(projectionShape,
					new CANNON.Vec3(0, 0, cylLength / 2.0));
        projection.addEventListener("collide", function (e) {
          let dangerPeriod =
						body.shapes[0].radius / e.contact.bi.velocity.length(); // Not quite right, but close
          if (Math.abs((e.contact.ri.length() / e.contact.bi.velocity.length()) - (e.contact.rj.length() / e.contact.bj.velocity.length())) < dangerPeriod) {
            console.log("Orbiting body collision predicted");
            // TODO: Change color of the orbiting body needs to be added here
          }
        });
        world.addEventListener("postStep", function () {
          if (world.bodies.indexOf(body) != -1) {
            projection.quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), body.velocity);
            projection.velocity.copy(body.velocity);
          } else {
            demo.removeVisual(projection);
            world.removeBody(projection);
            // TODO This causes a minor error in javascript. Figure out how to fix it
          }
        });
      	world.addBody(projection);
    	}
			/***********************************/
			/* addLinearPathProjection() - END */
			/***********************************/




			/**********************************/
			/* addCollisionBehavior() - BEGIN */
			/**********************************/
      function addCollisionBehavior(body, world) {
          body.addEventListener("collide", function (e) { demo.removeVisual(this); world.remove(this); });
      }
			/*******************************/
			/* addCollisionBehavior() - END*/
			/*******************************/




			/***********************/
			/* addVisual() - BEGIN */
			/***********************/

			/*
			* NOTE addVisual() is a wrapper function for
		 	* CANNON.Demo.prototype.addVisual()
			*/
			function addVisual(body, texture) {
				if (!texture) {
					demo.addVisual(body);
				} else {
					var settings = demo.settings;
			    // What geometry should be used?
			    var mesh;
			    if(body instanceof CANNON.Body){
			        //TODO add shape2mesh equivalent here
							//XXX 11:30pm 4/26 here is where I left off
			    }
			    if(mesh) {
			        // Add body
			        this.bodies.push(body);
			        this.visuals.push(mesh);
			        body.visualref = mesh;
			        body.visualref.visualId = this.bodies.length - 1;
			        //mesh.useQuaternion = true;
			        this.scene.add(mesh);
			    }
				}
			}
			/*********************/
			/* addVisual() - END */
			/*********************/




      var i = 0;
      demo.addScene("Bolides", function(){
        var world = demo.getWorld();
        var moonShape = new CANNON.Sphere(0.5);

				/*
				* TODO here is where the earth is generated, so here is where the
				* textures will go
				*/

        var planetShape = new CANNON.Sphere(8);
        var planet = new CANNON.Body({ mass: 0 });
        planet.addShape(planetShape);

        // Use the preStep callback to apply the gravity force on the moon.
        // This callback is evoked each timestep.
        world.addEventListener("preStep", function() {
          spawnBolides = demo.getSpawnBolides();
          var frequency = demo.getFrequency();
          if(spawnBolides){
            if((i % frequency) == 0){
              var bolide = generateBolide(5, moonShape);
              addEllipticalProjection(bolide, world); // Add the path projections!
              addCollisionBehavior(bolide, world)

              world.addBody(bolide);
              demo.addVisual(bolide);
            }
        	}

          i++;

        });

        // We add the objects to the world to simulate them
        //demo.spawnBolide(bolide);
        world.addBody(planet);
        //world.addBody(bolide);
        // And we add them to the demo to make them visible
        demo.addVisual(planet);
        //demo.addVisual(bolide);
        // spawnBolide(bolide);
      });

      demo.start();
     </script>
  </body>
</html>
