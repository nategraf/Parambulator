<!DOCTYPE html>
<html>
  <head>
    <title>cannon.js - callbacks demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <script src="js/cannon.min.js"></script>
    <script src="js/cannon.demo.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/smoothie.js"></script>
    <script src="dist/orb.min.js"></script>
    <script>
     	/**
     	* A demo showing how to use the preStep callback to add a force to a body.
     	* This will act like a force field.
     	*/

      const ZEROVEC = new CANNON.Vec3(0,0,0);
      const XUNITVEC = new CANNON.Vec3(1,0,0);
      const YUNITVEC = new CANNON.Vec3(0,1,0);
      const ZUNITVEC = new CANNON.Vec3(0,0,1);
      const GM = 300;
      const M1 = GM/orb.constants.common.G;
      console.log(GM);
      console.log(M1);

      var demo = new CANNON.Demo();

			/**************************/
			/* createEllipse() - BEGIN*/
			/**************************/
      CANNON.Trimesh.createEllipse = function (semimajor, eccentricity, tube,
				radialSegments, tubularSegments, arc) {

        semimajor = semimajor || 1;
        eccentricity = eccentricity || 0;
        tube = tube || 0.5;
        radialSegments = radialSegments || 8;
        tubularSegments = tubularSegments || 6;
        arc = arc || Math.PI * 2;

        var vertices = [];
        var indices = [];

        for ( var j = 0; j <= radialSegments; j ++ ) {
          for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            let radius = (semimajor * (1 - Math.pow(eccentricity,2)))/(1 +
							eccentricity * Math.cos(u));

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
					}
        }

        for ( var j = 1; j <= radialSegments; j ++ ) {
          for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }

        return new CANNON.Trimesh(vertices, indices);
      };
			/************************/
			/* createEllipse() - END*/
			/************************/



			/*************************************/
			/* addEllipticalProjection() - BEGIN */
			/*************************************/
      function addEllipticalProjection(body, world){
        let cylLength = 10;
        let x = [body.position.x, body.position.y, body.position.z];
        let xDot = [body.velocity.x, body.velocity.y, body.velocity.z];
        let orbitElems = orb.position.stateToKepler(x, xDot, 0, M1);
        let projectionShape = CANNON.Trimesh.createEllipse(orbitElems[0],
					orbitElems[1], body.shapes[0].radius, 8, 32);
        projectionShape.collisionResponse = false;
        let projection = new CANNON.Body({
          mass: 1,
          collisionFilterGroup: 2,
          collisionFilterMask: 2
        });
        let quat = new CANNON.Quaternion();
				// TODO fix this
        quat.setFromEuler(orbitElems[2], -orbitElems[4], orbitElems[3], 'ZYX');
        projection.addShape(projectionShape, ZEROVEC, quat);
        world.addEventListener("postStep", function () {
          if (world.bodies.indexOf(body) != -1) {}
          else {
            // If the body no longer exists, delete the projection
            demo.removeVisual(projection);
            world.removeBody(projection);
            // TODO This causes a minor error in javascript. Figure out how to fix it
          }
        });
        world.addBody(projection);
        demo.addVisual(projection);
      }
			/***********************************/
			/* addEllipticalProjection() - END */
			/***********************************/



			/**********************************/
			/* addCollisionBehavior() - BEGIN */
			/**********************************/
      function addCollisionBehavior(body, world) {
        body.addEventListener("collide", function (e) {
					demo.removeVisual(this); world.remove(this); });
        }
			/********************************/
			/* addCollisionBehavior() - END */
			/********************************/




      var spawnBolides = true;
			/****************************/
			/* generateBolide() - BEGIN */
			/****************************/
      function generateBolide(mass){
        var redEarth = demo.getRedEarth();
        var size = demo.getSize();
        var shape = new CANNON.Sphere(size);

        let randomMult = 1;

        var a = demo.getA() + Math.random()*randomMult;
        var e = demo.getE() + Math.random() * randomMult/5.0;
        var i = orb.common.deg2rad(demo.getI()) + Math.random() * randomMult;
        var O = orb.common.deg2rad(demo.getO()) + Math.random() * randomMult;
        var o = orb.common.deg2rad(demo.geto());
        var cartesian = orb.position.keplerian(a, e, i, O, o, 0, 0, 0, M1);

        var x = cartesian[0][0];
        var y = cartesian[0][1];
        var z = cartesian[0][2];

        var vx = (cartesian[1][0]);
        var vy = (cartesian[1][1]);
        var vz = (cartesian[1][2]);
        var bolide = new CANNON.Body({
          mass: mass,
          position: new CANNON.Vec3(x,y,z)
        });

        bolide.addShape(shape);
        bolide.velocity.set(vx,vy,vz);
        bolide.linearDamping = 0.0;

        bolide.preStep = function(){
          // Get the vector pointing from the moon to the planet center
          var bolide_to_planet = new CANNON.Vec3();
          this.position.negate(bolide_to_planet);
          // Get distance from planet to moon
          var distance = bolide_to_planet.length();
          // Now apply force on moon
          // Fore is pointing in the moon-planet direction
          bolide_to_planet.normalize();
          bolide_to_planet.mult((GM*mass)/Math.pow(distance,2),this.force);
        }


        return bolide;
      }
			/**************************/
			/* generateBolide() - END */
			/**************************/




			/*************************************/
			/* addLinearPathProjection() - BEGIN */
			/*************************************/
      function addLinearPathProjection(body, world) {
        let cylLength = 10;
        let projectionShape = new CANNON.Cylinder(body.shapes[0].radius,
					 body.shapes[0].radius, cylLength, 20);
        projectionShape.collisionResponse = false;
        let projection = new CANNON.Body({
          mass: 1,
          collisionFilterGroup: 2,
          collisionFilterMask: 2,
          position: body.position
        });
        projection.addShape(projectionShape,
					new CANNON.Vec3(0, 0, cylLength / 2.0));
        projection.addEventListener("collide", function (e) {
          let dangerPeriod =
						body.shapes[0].radius / e.contact.bi.velocity.length(); // Not quite right, but close
          if (Math.abs((e.contact.ri.length() / e.contact.bi.velocity.length()) - (e.contact.rj.length() / e.contact.bj.velocity.length())) < dangerPeriod) {
            console.log("Orbiting body collision predicted");
            // TODO: Change color of the orbiting body needs to be added here
          }
        });
        world.addEventListener("postStep", function () {
          if (world.bodies.indexOf(body) != -1) {
            projection.quaternion.setFromVectors(new CANNON.Vec3(0, 0, 1), body.velocity);
            projection.velocity.copy(body.velocity);
          } else {
            demo.removeVisual(projection);
            world.removeBody(projection);
            // TODO This causes a minor error in javascript. Figure out how to fix it
          }
        });
      	world.addBody(projection);
    	}
			/***********************************/
			/* addLinearPathProjection() - END */
			/***********************************/




			/**********************************/
			/* addCollisionBehavior() - BEGIN */
			/**********************************/
      function addCollisionBehavior(body, world) {
          body.addEventListener("collide", function (e) { demo.removeVisual(this); world.remove(this); });
      }
			/*******************************/
			/* addCollisionBehavior() - END*/
			/*******************************/




			/***********************/
			/* addVisual() - BEGIN */
			/***********************/

			/*
			* NOTE addVisual() is a wrapper function for
		 	* CANNON.Demo.prototype.addVisual()
			*/
			function addVisual(body, texture) {
				if (!texture) {
					demo.addVisual(body);
				} else {
					var settings = demo.settings;
			    // What geometry should be used?
			    var mesh;
			    if(body instanceof CANNON.Body){
			      var wireframe = settings.renderMode === "wireframe";
						var obj = new THREE.Object3D();
						var obj_extra = new THREE.Object3D();

						for (var l = 0; l < body.shapes.length; l++) {
							var shape = body.shapes[l];
							var mesh;
							switch(shape.type) {

								case CANNON.Shape.types.SPHERE:
									var cloudGeometry, cloudMaterial, cloudMesh;
									var cloudTexture = new THREE.TextureLoader().load("img/cloud_combined_2048.jpg");
									var sphere_geometry =
										/*
										* TODO figure out a way to change the polygon density,
										* such as including the densities as parameters. This will
										* cause complications though, as the number and order or
										* arguments varies based on what kind of object is being
										* created.
										*/
										new THREE.SphereGeometry(shape.radius,32, 32);
									mesh = new THREE.Mesh(sphere_geometry, texture);
									cloudGeometry = new THREE.SphereGeometry(
										shape.radius+0.05, 32, 32
									);
									cloudMaterial = new THREE.MeshPhongMaterial({
										map: cloudTexture,
										side: THREE.DoubleSide,
										opacity: 0.45,
										transparent: true,
										depthWrite: false
									});
									cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
									obj_extra.add(cloudMesh);
									break;

								case CANNON.Shape.types.PLANE:
									var geometry = new THREE.PlaneGeometry(10,10,4,4);
									mesh = new THREE.Object3D();
									var submesh = new THREE.Object3D();
			            var ground = new THREE.Mesh(geometry, this.currentMaterial);
			            ground.scale.set(100, 100, 100);
			            submesh.add(ground);
									ground.castShadow = true;
			            ground.receiveShadow = true;
			            mesh.add(submesh);
			            break;

								case CANNON.Shape.types.PARTICLE:
					        mesh =
										new THREE.Mesh(this.particleGeo, this.particleMaterial);
					        var s = this.settings;
					        mesh.scale.set(s.particleSize,
										s.particleSize,s.particleSize);
					        break;

								case CANNON.Shape.types.BOX:
						      var box_geometry =
										new THREE.BoxGeometry(shape.halfExtents.x*2,
						      		shape.halfExtents.y*2, shape.halfExtents.z*2 );
						      mesh = new THREE.Mesh(box_geometry, this.currentMaterial);
						      break;

								case CANNON.Shape.types.CONVEXPOLYHEDRON:
						      var geo = new THREE.Geometry();

						      // Add vertices
						      for (var i = 0; i < shape.vertices.length; i++) {
						        var v = shape.vertices[i];
						        geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
					        }

					        for(var i=0; i < shape.faces.length; i++){
					          var face = shape.faces[i];

						        // add triangles
						        var a = face[0];
						        for (var j = 1; j < face.length - 1; j++) {
						          var b = face[j];
						          var c = face[j + 1];
					            geo.faces.push(new THREE.Face3(a, b, c));
					          }
					        }
				          geo.computeBoundingSphere();
				          geo.computeFaceNormals();
				          mesh = new THREE.Mesh( geo, this.currentMaterial );
					        break;

								case CANNON.Shape.types.HEIGHTFIELD:
						      var geometry = new THREE.Geometry();

					        var v0 = new CANNON.Vec3();
					        var v1 = new CANNON.Vec3();
					        var v2 = new CANNON.Vec3();
						      for (var xi = 0; xi < shape.data.length - 1; xi++) {
						        for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
						          for (var k = 0; k < 2; k++) {
						            shape.getConvexTrianglePillar(xi, yi, k===0);
					              v0.copy(shape.pillarConvex.vertices[0]);
					              v1.copy(shape.pillarConvex.vertices[1]);
			                  v2.copy(shape.pillarConvex.vertices[2]);
			                  v0.vadd(shape.pillarOffset, v0);
						            v1.vadd(shape.pillarOffset, v1);
						            v2.vadd(shape.pillarOffset, v2);
						            geometry.vertices.push(
						              new THREE.Vector3(v0.x, v0.y, v0.z),
						              new THREE.Vector3(v1.x, v1.y, v1.z),
						              new THREE.Vector3(v2.x, v2.y, v2.z)
					              );
					              var i = geometry.vertices.length - 3;
					              geometry.faces.push(new THREE.Face3(i, i+1, i+2));
					            }
						        }
						      }
						      geometry.computeBoundingSphere();
						      geometry.computeFaceNormals();
						      mesh = new THREE.Mesh(geometry, this.currentMaterial);
						      break;

								case CANNON.Shape.types.TRIMESH:
					      	var geometry = new THREE.Geometry();

				          var v0 = new CANNON.Vec3();
				          var v1 = new CANNON.Vec3();
					        var v2 = new CANNON.Vec3();
					        for (var i = 0; i < shape.indices.length / 3; i++) {
					          shape.getTriangleVertices(i, v0, v1, v2);
					          geometry.vertices.push(
					            new THREE.Vector3(v0.x, v0.y, v0.z),
				              new THREE.Vector3(v1.x, v1.y, v1.z),
				              new THREE.Vector3(v2.x, v2.y, v2.z)
					          );
					          var j = geometry.vertices.length - 3;
					          geometry.faces.push(new THREE.Face3(j, j+1, j+2));
					        }
					        geometry.computeBoundingSphere();
					        geometry.computeFaceNormals();
				          mesh = new THREE.Mesh(geometry, this.currentMaterial);
				          break;

								default:
					        throw "Visual type not recognized: "+shape.type;
					    }

							mesh.receiveShadow = true;
							mesh.castShadow = true;
							if (mesh.children) {
								for(var i=0; i<mesh.children.length; i++){
		              mesh.children[i].castShadow = true;
		              mesh.children[i].receiveShadow = true;
		              if(mesh.children[i]){
		                for(var j=0; j<mesh.children[i].length; j++){
		                  mesh.children[i].children[j].castShadow = true;
		                  mesh.children[i].children[j].receiveShadow = true;
		                }
		              }
		            }
							}

							var o = body.shapeOffsets[l];
							var q = body.shapeOrientations[l];
							mesh.position.set(o.x, o.y, o.z);
							mesh.quaternion.set(q.x, q.y, q.z, q.w);

							obj.add(mesh);
						}
					}
			  }
			  if(obj) {
			    // Add body
			    demo.bodies.push(body);
			    demo.visuals.push(obj);
			    body.visualref = obj;
			    body.visualref.visualId = demo.bodies.length - 1;
			    //mesh.useQuaternion = true;
			    demo.scene.add(obj);
			  }

				if(obj_extra && (shape.type == CANNON.Shape.types.SPHERE)) {
					demo.visuals.push(obj_extra);
					demo.scene.add(obj_extra)
				}
			}
			/*********************/
			/* addVisual() - END */
			/*********************/

			function createGlow(body, type) {

				switch (type) {
					case WARNING:
						
						break;

					case DANGER:

						break;
				}
			}

      var i = 0;
      demo.addScene("Bolides", function(){
        var world = demo.getWorld();
        var moonShape = new CANNON.Sphere(0.5);

				/*
				* TODO here is where the earth is generated, so here is where the
				* textures will go
				*/
        var planetShape = new CANNON.Sphere(30);
        var planet = new CANNON.Body({ mass: 0 });
        planet.addShape(planetShape);

        // Use the preStep callback to apply the gravity force on the moon.
        // This callback is evoked each timestep.
        world.addEventListener("preStep", function() {
          spawnBolides = demo.getSpawnBolides();
          var frequency = demo.getFrequency();
          if(spawnBolides){
            if((i % frequency) == 0){
              var bolide = generateBolide(5, moonShape);
              addEllipticalProjection(bolide, world); // Add the path projections!
              addCollisionBehavior(bolide, world)

              world.addBody(bolide);
              demo.addVisual(bolide);
            }
        	}

          i++;

        });

        // We add the objects to the world to simulate them
        //demo.spawnBolide(bolide);
        world.addBody(planet);
        //world.addBody(bolide);
        var imgTexture = new THREE.TextureLoader().load("earth_big.jpg");
				var imgTextureBump = new THREE.TextureLoader().load("earth_bump_big.jpg");

				var material = new THREE.MeshPhongMaterial({
					map : imgTexture,
					bumpMap: imgTextureBump,
				})


        addVisual(planet, material);

				var starmap = new THREE.SphereGeometry(550,32,32);
				var starMaterial = new THREE.MeshBasicMaterial();
				starMaterial.map = new THREE.TextureLoader().load("img/stellar_map.jpg");
				starMaterial.side = THREE.BackSide;
				var starMesh = new THREE.Mesh(starmap, starMaterial);
				var star3d = new THREE.Object3D();
				star3d.add(starMesh);
				if (starMesh && star3d) {
					demo.visuals.push(star3d);
					demo.scene.add(star3d);
				} else {
					console.log("Couldn't create star map");
				}
				star3d.add(starMesh);
        //demo.addVisual(bolide);
        // spawnBolide(bolide);
      });

      demo.start();
     </script>
  </body>
</html>
